---
title: The technical complexities of external authorization
pubDate: 2024-10-10 15:15
author: Cormontagne Romain
tags:
  - "CSharp"
  - ".NET"
  - APIs
imgUrl: '../../assets/record-types-cover.jpg'
description: The record class is useful to describe data models ! But how exactly does it work, and how can we benefit from it ? Learn everything there is to know about this C# class type here !
layout: '../../layouts/BlogPost.astro'
---

# Everything there is to know about the `record` class
---
When we create classes in .NET projects, most of them are actually what we could call _model types_, e.g. classes which are mainly used for data transfer from and to back-end API services, so their role is typically to represent data.

## The introduction of the `record` type

In 2020, with the release of .NET 5, Microsoft has introduced a new `record` class type, which decreased the typical code developers have to write. Records are defined similarly to classes, the only difference being the keyword : `record` is used instead of `class`.

## Setting values

When using records, to assign a value to a record, the `init` keyword is used to replace the classical `set`. Its behaviour is the same, though it has to follow two rules:
- Init values can be set in the constructor
- Init values can be set during the initialization of the object
Once created, a `record` object cannot be changed. It's immutable.

## Updating values

If we want to change the values of a record, it is necessary to create a new one. Fortunately, this can be achieved simply by using the `with` keyword. Here's a usage example :
```cs
var email = "test@example.com";
var id = "12345";
var person = new PersonRecord(email, id)
{
    FirstName = "John"
};
 
person = person with { FirstName = "Jane" };
```

## Equality and comparison

Unlike standard model classes, where it's crucial to implement the `IComparable<T>` and `IEquatable<T>` interfaces and override the equality operators, with record types, these methods are generated automatically.

## Hashing and `ToString()`

With record types, the `GetHashCode()` method, which is oftentimes daunting to implement, is generated by the compiler, which frees the developer from maintenance concerns.

The `ToString` method is also unnecessary to implement in most cases with the record types, the exception being if it contains other object types as attributes, such as collections, for instance.

## Performance Considerations

Here, we will compare the performance of record types compared to other types in several typical operations. Several benchmarks have been established to highlight the speed of the operations on reference types, value types and records.

- **Cloning:** the benchmarks establish that cloning a record is 1.12 times faster than a value type and 1.23 times faster than a reference type.
- **Computing Hash:** hashing a record is slower this time, with reference types being hashed 1.02 times faster, and value types, 1.05 times faster
- **JSON Serialization:** In terms of (de)serialization (from)into JSON values, record types have proven to be faster than value types, but slower than reference types.
- **Looping and Sorting:** Sorting lists of the different types using a `foreach` statement have shown that sorting a list of record values is slightly faster than for value types, but slower than for reference types. Regarding the `List<T>.Sort()` methtod, records are slightly faster sorted than reference types, and faster than value types are.

## Sources

- <https://dotnettips.wordpress.com/2021/02/26/everything-you-want-to-know-about-the-record-type-in-net-5-but-were-afraid-to-ask/?utm_source=newsletter.csharpdigest.net&utm_medium=newsletter&utm_campaign=10-lessons-i-learned-from-using-aspire-in-production&_bhlid=02b275dc8f7af750ddde9a88efe8c83efdcd1cbe>
- <https://www.youtube.com/watch?v=XaYwiGBn3p8> (Cover Image)